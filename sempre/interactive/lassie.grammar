(rule $ROOT ($Theorem) (IdentityFn) (anchored 1))

# Theorems
(rule $Theorem ($TOKEN) (SimpleLexiconFn (type en.theorem)) (anchored 1))
(rule $Theorem (theorem $CP) (lambda c (call listValue (var c))) (anchored 1))


# Theorem features
(rule $Effect ($TOKEN) (SimpleLexiconFn (type en.effect)) (anchored 1))
(rule $CP (that $Effect) (lambda e (call has (string theorem_effect) (var e))) (anchored 1))
(rule $CP (which $Effect) (lambda e (call has (string theorem_effect) (var e))) (anchored 1))

(rule $Domain ($TOKEN) (SimpleLexiconFn (type en.domain)) (anchored 1))
(rule $CP (in the $Domain) (lambda d (call has (string theorem_domain) (var d))) (anchored 1))


# Set operations
(rule $CP ($CP and $CP) (lambda c1 (lambda c2 (and (var c1) (var c2)))) (anchored 1))
(rule $CP ($CP $CP) (lambda c1 (lambda c2 (and (var c1) (var c2)))) (anchored 1))

(rule $CP ($CP or $CP) (lambda c1 (lambda c2 (or (var c1) (var c2)))) (anchored 1))


# Contexts
(rule $Context ($MathExp) (IdentityFn) (anchored 1))
(rule $CP (on $Context) (lambda e (call fromContext (var e))) (anchored 1))


# Math expressions (ideally quotes from goal)
(rule $MathExp ($Number) (IdentityFn) (anchored 1))
(rule $Number ($TOKEN) (NumberFn) (anchored 1))

(rule $MathExp ($Var) (IdentityFn) (anchored 1))
(rule $Var ($TOKEN) (IdentityFn) (anchored 1))

(for @op (+ -)
     (rule $MathExp
     	   ($MathExp @op $MathExp)
	   (lambda n1  (lambda n2 (@op (var n1) (var n2))))
	   (anchored 1)))