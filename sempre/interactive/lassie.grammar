(rule $ROOT ($Tactic) (lambda t (: tacReturn (var t))) (anchored 1))

(for @then (THEN //)
     (rule $Tactic ($Tactic @then $Tactic) (lambda t1 (lambda t2 (call tacThen (var t1) (var t2)))) (anchored 1)))

(rule $Tactic ($Tactical $Theorem) (lambda t1 (lambda t2 (call tacApply (var t1) (var t2)))) (anchored 1))
(rule $Tactic ($LTactical $ThmList) (lambda t1 (lambda t2 (call tacApply (var t1) (var t2)))) (anchored 1))

# Tacticals
(rule $Tactical (rewrite_tac) (ConstantFn rewrite_tac) (anchored 1))
(rule $LTactical (fs) (ConstantFn fs) (anchored 1))

# Theorems
#(rule $Theorem ($TOKEN) (SimpleLexiconFn (type en.theorem)) (anchored 1))
(rule $Theorems ($Theorem) (IdentityFn) (anchored 1))
(rule $Theorems ($Theorem, $Theorems) (lambda t1 (lambda t2 (call thmListCons (var t1) (var t2)))) (anchored 1))
(rule $ThmList ([ $Theorems ]) (lambda thms (call mkThmList (var thms))) (anchored 1))
(rule $ThmList ([ ]) (ConstantFn []) (anchored 1))

(rule $Theorem (REAL) (ConstantFn RealTheory.REAL) (anchored 1))
(rule $Theorem (POW_2) (ConstantFn POW_2) (anchored 1))

# Any token not recognized is assumed to be a custom tactic
#(rule $Tactic ($TOKEN) (IdentityFn) (anchored 1))
