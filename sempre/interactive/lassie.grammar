########################################################################
# GRAMMAR FOR NATURAL PROOF EXPRESSIONS
#
# Refer to SEMPRE's documentation for general indications on rule
# construction.
#
# Currently, domain knowledge comes from two sources. The lassie.lexicon
# file contains component names (e.g. fs) and with their types
# (e.g. thmlist->tactic, used for sound applications). Features of those
# components (e.g. their natural name, their class/type) are read from
# lassie.db into the TacticWorld.
#
# TacticWorld.java holds the main semantics of Lassie's operations, as
# we piggy back on the DALExecutor for handling the semantic part of
# this grammar. DALExecutor interprets semantic expression in a "world"
# containing "items". We superifcially follow this convention where HOL
# components can be considered the "items" of our "tactic-world".

(include lassie.generated.grammar)

(rule $ROOT ($tactic) (lambda t (: tacReturn (var t))) (anchored 1))
(for @cat ($tactic $ThmListTactic $ThmTactic)
     (rule @cat (\( @cat \)) (lambda t (call parens (var t))) (anchored 1)))

# Litteral Components Import
(rule $tactic ($TOKEN) (SimpleLexiconFn (type tactic)) (anchored 1))
(rule $thm ($TOKEN) (SimpleLexiconFn (type thm)) (anchored 1))
(rule $thm->tactic ($TOKEN) (SimpleLexiconFn (type "thm -> tactic")) (anchored 1))
(rule $thmlist->tactic ($TOKEN) (SimpleLexiconFn (type "thmlist -> tactic")) (anchored 1))
(rule $tactic->tactic ($TOKEN) (SimpleLexiconFn (type "tactic -> tactic")) (anchored 1))
(rule $thm->thm ($TOKEN) (SimpleLexiconFn (type "thm -> thm")) (anchored 1))
(rule $termquotation->tactic ($TOKEN) (SimpleLexiconFn (type "term quotation -> tactic")) (anchored 1))
(rule $int->tactic->tactic ($TOKEN) (SimpleLexiconFn (type "int -> tactic -> tactic")) (anchored 1))

# Features
(rule $Feature ($PHRASE) (SimpleLexiconFn (type feature)) (anchored 1))
(rule $Set ($Feature) (lambda n (call fromFeature (var n))) (anchored 1))
(rule $Set ($Set $Set) (lambda s1 (lambda s2 (call intersect (var s1) (var s2)))) (anchored 1))

# Casting sets to individual types
(rule $tactic' ($Set) (lambda s (: strReturn (call set2string (call intersect (var s) (call fromFeature "type.tactic"))))) (anchored 1))
(rule $tactic ($tactic') (ChoiceFn) (anchored 1))

(rule $thm' ($Set) (lambda s (: strReturn (call set2string (call intersect (var s) (call fromFeature "type.thm"))))) (anchored 1))
(rule $thm ($thm') (ChoiceFn) (anchored 1))

(rule $thm->tactic' ($Set) (lambda s (: strReturn (call set2string (call intersect (var s) (call fromFeature "type.thm -> tactic"))))) (anchored 1))
(rule $thm->tactic ($thm->tactic') (ChoiceFn) (anchored 1))

(rule $thmlist->tactic' ($Set) (lambda s (: strReturn (call set2string (call intersect (var s) (call fromFeature "type.thmlist -> tactic"))))) (anchored 1))
(rule $thmlist->tactic ($thmlist->tactic') (ChoiceFn) (anchored 1))

(rule $tactic->tactic' ($Set) (lambda s (: strReturn (call set2string (call intersect (var s) (call fromFeature "type.tactic -> tactic"))))) (anchored 1))
(rule $tactic->tactic ($tactic->tactic') (ChoiceFn) (anchored 1))

(rule $thm->thm' ($Set) (lambda s (: strReturn (call set2string (call intersect (var s) (call fromFeature "type.thm -> thm"))))) (anchored 1))
(rule $thm->thm ($thm->thm') (ChoiceFn) (anchored 1))

(rule $termquotation->tactic' ($Set) (lambda s (: strReturn (call set2string (call intersect (var s) (call fromFeature "type.termquotation -> tactic"))))) (anchored 1))
(rule $termquotation->tactic ($termquotation->tactic') (ChoiceFn) (anchored 1))

(rule $int->tactic->tactic' ($Set) (lambda s (: strReturn (call set2string (call intersect (var s) (call fromFeature "type.int -> tactic -> tactic"))))) (anchored 1))
(rule $int->tactic->tactic ($int->tactic->tactic') (ChoiceFn) (anchored 1))

# Applications
(rule $tactic ($thm->tactic $thm) (lambda t1 (lambda t2 (call parens (call app (var t1) (var t2))))) (anchored 1))
(rule $tactic ($thmlist->tactic $thmlist) (lambda t1 (lambda t2 (call parens (call app (var t1) (var t2))))) (anchored 1))
(rule $tactic ($tactic->tactic $tactic) (lambda t1 (lambda t2 (call parens (call app (var t1) (var t2))))) (anchored 1))
(rule $thm ($thm->thm $thm) (lambda t1 (lambda t2 (call parens (call app (var t1) (var t2))))) (anchored 1))
(rule $tactic ($termquotation->tactic $Term) (lambda t1 (lambda t2 (call parens (call app (var t1) (var t2))))) (anchored 1))
(rule $tactic->tactic ($int->tactic->tactic $Number) (lambda t1 (lambda n (call parens (call app (var t1) (var n ))))) (anchored 1))

# Tactic composition
(rule $tactic ($tactic THEN $tactic) (lambda t1 (lambda t2 (call then (var t1) (var t2)))) (anchored 1))
(rule $tactic ($tactic THEN1 $tactic) (lambda t1 (lambda t2 (call then1 (var t1) (call parens (var t2))))) (anchored 1))

# Assumptions
(rule $tactic ($Term by $tactic) (lambda q (lambda t (call op by (var q) (call parens (var t))))) (anchored 1))

# Theorem Lists
(rule $Thms ($thm) (IdentityFn) (anchored 1))
(rule $Thms ($thm , $Thms) (lambda t1 (lambda t2 (call cons (var t1) (var t2)))) (anchored 1))
(rule $Thms ($thm and $Thms) (lambda t1 (lambda t2 (call cons (var t1) (var t2)))) (anchored 1))
(rule $thmlist ([ $Thms ]) (lambda thms (call list (var thms))) (anchored 1))
(rule $thmlist ($Thms) (lambda thms (call list (var thms))) (anchored 1))
(rule $thmlist ([ ]) (ConstantFn []) (anchored 1))
(rule $thmlist (nothing) (ConstantFn []) (anchored 1))

# Other
(rule $Term (` $PHRASE `) (lambda e (call quote (var e))) (anchored 1))
(rule $Number ($TOKEN) (NumberFn) (anchored 1))


